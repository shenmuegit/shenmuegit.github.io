---
layout: default
title: å¹¶å‘ç¼–ç¨‹åŸºçŸ³
parent: JDK 1.5 æ—¶ä»£
grand_parent: JavaæŠ€æœ¯ç”Ÿæ€æ¼”è¿›
nav_order: 2
---

# å¹¶å‘ç¼–ç¨‹åŸºçŸ³

<p align="center">
  <img src="https://img.shields.io/badge/éš¾åº¦-é«˜çº§-red" alt="éš¾åº¦">
  <img src="https://img.shields.io/badge/é˜…è¯»æ—¶é•¿-50åˆ†é’Ÿ-blue" alt="æ—¶é•¿">
  <img src="https://img.shields.io/badge/JDK-1.5-red" alt="JDK">
</p>

---

## ğŸ“ æ—¶é—´çº¿å®šä½

```mermaid
timeline
    title Java å¹¶å‘æ¼”è¿›èµ·ç‚¹
    section å‰ JDK 1.5
        JDK 1.0-1.4 : Thread + synchronized
                    : wait/notify
    section JDK 1.5 (2004)
        å¹¶å‘é©å‘½ : ğŸ“ JUC åŒ…
                 : Executor æ¡†æ¶
                 : Lock æ¥å£
                 : å¹¶å‘é›†åˆ
    section åç»­æ¼”è¿›
        JDK 7 : Fork/Join
        JDK 8 : CompletableFuture
        JDK 21 : Virtual Thread
```

---

## ğŸ¯ äº†è§£ç›®æ ‡

- âœ… ç†è§£ JDK 1.4 å¹¶å‘ç¼–ç¨‹çš„å›°å¢ƒ
- âœ… æŒæ¡ Executor æ¡†æ¶çš„è®¾è®¡æ€æƒ³
- âœ… ç†è§£ Lock ä¸ synchronized çš„åŒºåˆ«
- âœ… äº†è§£å¹¶å‘é›†åˆçš„å®ç°åŸç†
- âœ… è®¤è¯† Doug Lea å¯¹ Java å¹¶å‘çš„è´¡çŒ®

---

## ğŸ“– ç« èŠ‚æ‘˜è¦

JDK 1.5 å¼•å…¥çš„ `java.util.concurrent`ï¼ˆJUCï¼‰åŒ…æ˜¯ Java å¹¶å‘ç¼–ç¨‹çš„é‡Œç¨‹ç¢‘ã€‚å®ƒæä¾›äº† Executor æ¡†æ¶ã€Lock æ¥å£ã€å¹¶å‘é›†åˆç­‰æ ¸å¿ƒç»„ä»¶ï¼Œå½»åº•æ”¹å˜äº† Java å¤šçº¿ç¨‹ç¼–ç¨‹çš„æ–¹å¼ã€‚

---

## 1. å†å²èƒŒæ™¯ä¸ç—›ç‚¹

### 1.1 JDK 1.4 çš„å¹¶å‘å›°å¢ƒ

åœ¨ JUC åŒ…å‡ºç°ä¹‹å‰ï¼ŒJava å¹¶å‘ç¼–ç¨‹åªæœ‰åŸºç¡€å·¥å…·ï¼š

```java
// JDK 1.4: æ‰‹åŠ¨ç®¡ç†çº¿ç¨‹
public class OldStyleConcurrency {
    
    public void processTasksOldWay(List<Runnable> tasks) {
        // é—®é¢˜1: æ¯ä¸ªä»»åŠ¡åˆ›å»ºæ–°çº¿ç¨‹ï¼Œå¼€é”€å¤§
        for (Runnable task : tasks) {
            Thread t = new Thread(task);
            t.start();
        }
        // é—®é¢˜2: æ— æ³•è·å–è¿”å›å€¼
        // é—®é¢˜3: æ— æ³•ç»Ÿä¸€ç®¡ç†çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ
        // é—®é¢˜4: æ— æ³•æ§åˆ¶å¹¶å‘æ•°é‡
    }
    
    // åŒæ­¥åªæœ‰ synchronizedï¼Œç²’åº¦ç²—
    private final Object lock = new Object();
    
    public void synchronizedMethod() {
        synchronized (lock) {
            // é—®é¢˜: æ— æ³•å°è¯•è·å–é”ã€æ— æ³•è®¾ç½®è¶…æ—¶
            // æ— æ³•å®ç°å…¬å¹³é”ã€è¯»å†™åˆ†ç¦»
        }
    }
}
```

**ä¸»è¦ç—›ç‚¹**ï¼š

| ç—›ç‚¹ | å½±å“ |
|------|------|
| çº¿ç¨‹åˆ›å»ºå¼€é”€å¤§ | æ¯ä¸ªä»»åŠ¡ä¸€ä¸ªçº¿ç¨‹ï¼Œèµ„æºæµªè´¹ |
| æ— æ³•è·å–å¼‚æ­¥ç»“æœ | Runnable æ²¡æœ‰è¿”å›å€¼ |
| åŒæ­¥æ‰‹æ®µå•ä¸€ | åªæœ‰ synchronizedï¼Œä¸å¤Ÿçµæ´» |
| ç¼ºä¹çº¿ç¨‹å®‰å…¨é›†åˆ | åªæœ‰ Vectorã€Hashtableï¼Œæ•ˆç‡ä½ |
| çº¿ç¨‹é—´åä½œå›°éš¾ | wait/notify æ˜“å‡ºé”™ |

### 1.2 å¤šæ ¸æ—¶ä»£çš„æŒ‘æˆ˜

```mermaid
graph LR
    A[2000å¹´: å•æ ¸ CPU] --> B[2005å¹´: åŒæ ¸ CPU]
    B --> C[2010å¹´: å››æ ¸ CPU]
    C --> D[ç°åœ¨: ä¼—æ ¸ CPU]
    
    A -.-> E[å•çº¿ç¨‹ç¨‹åº]
    B -.-> F[éœ€è¦å¹¶å‘ç¼–ç¨‹]
    C -.-> G[éœ€è¦é«˜æ•ˆå¹¶å‘æ¡†æ¶]
    D -.-> H[éœ€è¦ç®€åŒ–å¹¶å‘æ¨¡å‹]
```

2005 å¹´å‰åï¼ŒCPU å‚å•†å¼€å§‹è½¬å‘å¤šæ ¸æ¶æ„ã€‚å•çº¿ç¨‹ç¨‹åºæ— æ³•å……åˆ†åˆ©ç”¨å¤šæ ¸æ€§èƒ½ï¼ŒJava æ€¥éœ€æ›´å¥½çš„å¹¶å‘ç¼–ç¨‹æ”¯æŒã€‚

---

## 2. Executor æ¡†æ¶

### 2.1 æ ¸å¿ƒæ€æƒ³ï¼šä»»åŠ¡ä¸æ‰§è¡Œåˆ†ç¦»

```mermaid
graph TB
    subgraph ä¼ ç»Ÿæ–¹å¼
        A1[ä»»åŠ¡] --> B1[Thread]
        A2[ä»»åŠ¡] --> B2[Thread]
        A3[ä»»åŠ¡] --> B3[Thread]
    end
    
    subgraph Executor æ¡†æ¶
        C1[ä»»åŠ¡] --> D[ExecutorService]
        C2[ä»»åŠ¡] --> D
        C3[ä»»åŠ¡] --> D
        D --> E1[çº¿ç¨‹1]
        D --> E2[çº¿ç¨‹2]
    end
```

### 2.2 æ ¸å¿ƒæ¥å£

```java
// Executor: æœ€åŸºç¡€çš„æ‰§è¡Œå™¨æ¥å£
public interface Executor {
    void execute(Runnable command);
}

// ExecutorService: å¢å¼ºçš„æ‰§è¡Œå™¨ï¼Œæ”¯æŒç”Ÿå‘½å‘¨æœŸç®¡ç†
public interface ExecutorService extends Executor {
    void shutdown();                          // ä¼˜é›…å…³é—­
    List<Runnable> shutdownNow();             // ç«‹å³å…³é—­
    boolean isShutdown();                     // æ˜¯å¦å·²å…³é—­
    <T> Future<T> submit(Callable<T> task);   // æäº¤æœ‰è¿”å›å€¼çš„ä»»åŠ¡
    <T> Future<T> submit(Runnable task, T result);
}

// Callable: æœ‰è¿”å›å€¼çš„ä»»åŠ¡
public interface Callable<V> {
    V call() throws Exception;
}

// Future: å¼‚æ­¥è®¡ç®—çš„ç»“æœ
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) throws TimeoutException;
}
```

### 2.3 çº¿ç¨‹æ± å®ç°

```java
// åˆ›å»ºçº¿ç¨‹æ± çš„å¸¸ç”¨æ–¹å¼
ExecutorService fixedPool = Executors.newFixedThreadPool(10);
ExecutorService cachedPool = Executors.newCachedThreadPool();
ExecutorService singlePool = Executors.newSingleThreadExecutor();
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(5);

// æ¨èï¼šç›´æ¥ä½¿ç”¨ ThreadPoolExecutor è‡ªå®šä¹‰å‚æ•°
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                      // corePoolSize: æ ¸å¿ƒçº¿ç¨‹æ•°
    10,                     // maximumPoolSize: æœ€å¤§çº¿ç¨‹æ•°
    60, TimeUnit.SECONDS,   // keepAliveTime: ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
    new LinkedBlockingQueue<>(100),  // workQueue: ä»»åŠ¡é˜Ÿåˆ—
    new ThreadPoolExecutor.CallerRunsPolicy()  // æ‹’ç»ç­–ç•¥
);
```

### 2.4 çº¿ç¨‹æ± å·¥ä½œåŸç†

```mermaid
flowchart TB
    A[æäº¤ä»»åŠ¡] --> B{æ ¸å¿ƒçº¿ç¨‹å·²æ»¡?}
    B -->|å¦| C[åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ]
    B -->|æ˜¯| D{é˜Ÿåˆ—å·²æ»¡?}
    D -->|å¦| E[ä»»åŠ¡å…¥é˜Ÿç­‰å¾…]
    D -->|æ˜¯| F{è¾¾åˆ°æœ€å¤§çº¿ç¨‹?}
    F -->|å¦| G[åˆ›å»ºä¸´æ—¶çº¿ç¨‹æ‰§è¡Œ]
    F -->|æ˜¯| H[æ‰§è¡Œæ‹’ç»ç­–ç•¥]
    
    H --> H1[AbortPolicy: æŠ›å¼‚å¸¸]
    H --> H2[CallerRunsPolicy: è°ƒç”¨è€…æ‰§è¡Œ]
    H --> H3[DiscardPolicy: é™é»˜ä¸¢å¼ƒ]
    H --> H4[DiscardOldestPolicy: ä¸¢å¼ƒæœ€è€ä»»åŠ¡]
```

### 2.5 ä»£ç æ¼”è¿›ç¤ºä¾‹

```java
// ========== JDK 1.4 å†™æ³• ==========
public class OldConcurrency {
    public void processTasks(List<Runnable> tasks) {
        List<Thread> threads = new ArrayList<>();
        
        // æ‰‹åŠ¨åˆ›å»ºçº¿ç¨‹
        for (Runnable task : tasks) {
            Thread t = new Thread(task);
            threads.add(t);
            t.start();
        }
        
        // æ‰‹åŠ¨ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for (Thread t : threads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

// ========== JDK 1.5 å†™æ³• ==========
public class NewConcurrency {
    private final ExecutorService executor = Executors.newFixedThreadPool(10);
    
    public void processTasks(List<Callable<String>> tasks) 
            throws InterruptedException {
        // æäº¤æ‰€æœ‰ä»»åŠ¡ï¼Œè·å– Future åˆ—è¡¨
        List<Future<String>> futures = executor.invokeAll(tasks);
        
        // è·å–ç»“æœ
        for (Future<String> future : futures) {
            try {
                String result = future.get();  // é˜»å¡ç­‰å¾…ç»“æœ
                System.out.println("Result: " + result);
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
    }
    
    public void shutdown() {
        executor.shutdown();
    }
}
```

---

## 3. Lock æ¥å£

### 3.1 Lock vs synchronized

```java
// synchronized: éšå¼é”
public synchronized void syncMethod() {
    // è‡ªåŠ¨è·å–é”ï¼Œæ–¹æ³•ç»“æŸè‡ªåŠ¨é‡Šæ”¾
}

// Lock: æ˜¾å¼é”
private final Lock lock = new ReentrantLock();

public void lockMethod() {
    lock.lock();  // æ˜¾å¼è·å–é”
    try {
        // ä¸´ç•ŒåŒºä»£ç 
    } finally {
        lock.unlock();  // å¿…é¡»åœ¨ finally ä¸­é‡Šæ”¾
    }
}
```

### 3.2 Lock çš„ä¼˜åŠ¿

| ç‰¹æ€§ | synchronized | Lock |
|------|:------------:|:----:|
| å°è¯•è·å–é” | âŒ | âœ… `tryLock()` |
| è¶…æ—¶è·å– | âŒ | âœ… `tryLock(time, unit)` |
| å¯ä¸­æ–­è·å– | âŒ | âœ… `lockInterruptibly()` |
| å…¬å¹³é” | âŒ | âœ… `new ReentrantLock(true)` |
| å¤šæ¡ä»¶å˜é‡ | âŒ | âœ… `newCondition()` |
| è¯»å†™åˆ†ç¦» | âŒ | âœ… `ReadWriteLock` |

### 3.3 ReentrantLock ç¤ºä¾‹

```java
public class BankAccount {
    private final Lock lock = new ReentrantLock();
    private double balance;
    
    // å°è¯•è½¬è´¦ï¼Œå¤±è´¥ç«‹å³è¿”å›
    public boolean tryTransfer(BankAccount target, double amount) {
        // å°è¯•è·å–é”ï¼Œé¿å…æ­»é”
        if (lock.tryLock()) {
            try {
                if (target.lock.tryLock()) {
                    try {
                        if (balance >= amount) {
                            balance -= amount;
                            target.balance += amount;
                            return true;
                        }
                    } finally {
                        target.lock.unlock();
                    }
                }
            } finally {
                lock.unlock();
            }
        }
        return false;
    }
}
```

### 3.4 ReadWriteLock è¯»å†™é”

```java
public class CachedData {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    private Object data;
    
    // å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è¯»
    public Object read() {
        readLock.lock();
        try {
            return data;
        } finally {
            readLock.unlock();
        }
    }
    
    // å†™æ“ä½œäº’æ–¥
    public void write(Object newData) {
        writeLock.lock();
        try {
            data = newData;
        } finally {
            writeLock.unlock();
        }
    }
}
```

---

## 4. å¹¶å‘é›†åˆ

### 4.1 ConcurrentHashMap

> ğŸ’¼ **é¢è¯•è€ƒç‚¹**ï¼šConcurrentHashMap çš„åˆ†æ®µé”æœºåˆ¶æ˜¯é¢è¯•é«˜é¢‘é¢˜ã€‚

JDK 1.5 çš„ ConcurrentHashMap ä½¿ç”¨åˆ†æ®µé”å®ç°ï¼š

```mermaid
graph TB
    subgraph ConcurrentHashMap JDK 1.5
        A[æ•´ä¸ª Map] --> S1[Segment 0]
        A --> S2[Segment 1]
        A --> S3[Segment 2]
        A --> S4[Segment n...]
        
        S1 --> H1[HashEntry æ•°ç»„]
        S2 --> H2[HashEntry æ•°ç»„]
    end
```

```java
// çº¿ç¨‹å®‰å…¨çš„ä½¿ç”¨æ–¹å¼
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// åŸå­æ“ä½œ
map.putIfAbsent("key", 1);           // ä¸å­˜åœ¨æ‰æ”¾å…¥
map.remove("key", 1);                 // å€¼åŒ¹é…æ‰åˆ é™¤
map.replace("key", 1, 2);             // å€¼åŒ¹é…æ‰æ›¿æ¢

// å¯¹æ¯”æ—§æ–¹æ¡ˆ
// Hashtable: æ•´ä¸ªè¡¨ä¸€æŠŠé”ï¼Œæ•ˆç‡ä½
// Collections.synchronizedMap(): ä¹Ÿæ˜¯æ•´è¡¨åŠ é”
```

**åˆ†æ®µé”åŸç†ï¼ˆJDK 1.5-1.7ï¼‰**ï¼š

| æ“ä½œ | é”èŒƒå›´ |
|------|--------|
| get | æ— é”ï¼ˆvolatile è¯»ï¼‰ |
| put | é”å®šå¯¹åº”çš„ Segment |
| size | å…ˆå°è¯•æ— é”ï¼Œå¤±è´¥åˆ™é”å…¨éƒ¨ Segment |

### 4.2 CopyOnWriteArrayList

é€‚ç”¨äºè¯»å¤šå†™å°‘çš„åœºæ™¯ï¼š

```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();

// å†™æ“ä½œï¼šå¤åˆ¶æ•´ä¸ªæ•°ç»„
list.add("item");  // åˆ›å»ºæ–°æ•°ç»„ï¼Œå¤åˆ¶æ—§æ•°æ®ï¼Œæ·»åŠ æ–°å…ƒç´ 

// è¯»æ“ä½œï¼šæ— é”ç›´æ¥è¯»
String item = list.get(0);  // ç›´æ¥è®¿é—®å½“å‰æ•°ç»„

// è¿­ä»£å®‰å…¨ï¼šå¿«ç…§è¿­ä»£
for (String s : list) {
    // è¿­ä»£æœŸé—´å…¶ä»–çº¿ç¨‹ä¿®æ”¹ä¸å½±å“æœ¬æ¬¡è¿­ä»£
}
```

### 4.3 é˜»å¡é˜Ÿåˆ—

```java
// BlockingQueue: çº¿ç¨‹é—´ä¼ é€’æ•°æ®çš„åˆ©å™¨
BlockingQueue<Task> queue = new LinkedBlockingQueue<>(100);

// ç”Ÿäº§è€…
queue.put(task);      // é˜Ÿåˆ—æ»¡æ—¶é˜»å¡
queue.offer(task);    // é˜Ÿåˆ—æ»¡æ—¶è¿”å› false
queue.offer(task, 1, TimeUnit.SECONDS);  // è¶…æ—¶ç‰ˆæœ¬

// æ¶ˆè´¹è€…
Task task = queue.take();   // é˜Ÿåˆ—ç©ºæ—¶é˜»å¡
Task task = queue.poll();   // é˜Ÿåˆ—ç©ºæ—¶è¿”å› null
Task task = queue.poll(1, TimeUnit.SECONDS);  // è¶…æ—¶ç‰ˆæœ¬
```

å¸¸ç”¨é˜»å¡é˜Ÿåˆ—ï¼š

| é˜Ÿåˆ— | ç‰¹ç‚¹ |
|------|------|
| `ArrayBlockingQueue` | æœ‰ç•Œæ•°ç»„é˜Ÿåˆ— |
| `LinkedBlockingQueue` | å¯é€‰æœ‰ç•Œé“¾è¡¨é˜Ÿåˆ— |
| `PriorityBlockingQueue` | ä¼˜å…ˆçº§é˜Ÿåˆ— |
| `SynchronousQueue` | ä¸å­˜å‚¨å…ƒç´ ï¼Œç›´æ¥ä¼ é€’ |

---

## 5. åŸå­ç±»ä¸ CAS

### 5.1 CAS åŸç†

CASï¼ˆCompare And Swapï¼‰æ˜¯æ— é”å¹¶å‘çš„åŸºç¡€ï¼š

```mermaid
flowchart LR
    A[è¯»å–å½“å‰å€¼ V] --> B[è®¡ç®—æ–°å€¼ N]
    B --> C{V == é¢„æœŸå€¼ E?}
    C -->|æ˜¯| D[æ›´æ–°ä¸º N]
    C -->|å¦| E[é‡æ–°è¯»å–ï¼Œé‡è¯•]
    E --> A
```

### 5.2 åŸå­ç±»ä½¿ç”¨

```java
// AtomicInteger: åŸå­æ•´æ•°
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet();     // ++i
counter.getAndIncrement();     // i++
counter.compareAndSet(0, 1);   // CAS æ“ä½œ

// AtomicReference: åŸå­å¼•ç”¨
AtomicReference<User> userRef = new AtomicReference<>();
userRef.compareAndSet(oldUser, newUser);

// AtomicStampedReference: å¸¦ç‰ˆæœ¬å·ï¼Œè§£å†³ ABA é—®é¢˜
AtomicStampedReference<Integer> ref = 
    new AtomicStampedReference<>(100, 0);
ref.compareAndSet(100, 101, 0, 1);  // å€¼å’Œç‰ˆæœ¬å·éƒ½è¦åŒ¹é…
```

### 5.3 ä»£ç æ¼”è¿›

```java
// ========== synchronized æ–¹å¼ ==========
public class SyncCounter {
    private int count = 0;
    
    public synchronized int increment() {
        return ++count;
    }
}

// ========== åŸå­ç±»æ–¹å¼ ==========
public class AtomicCounter {
    private final AtomicInteger count = new AtomicInteger(0);
    
    public int increment() {
        return count.incrementAndGet();  // æ— é”ï¼Œæ€§èƒ½æ›´é«˜
    }
}
```

---

## 6. çº¿ç¨‹é—´åä½œå·¥å…·

### 6.1 CountDownLatch

ä¸€æ¬¡æ€§é—¨æ “ï¼Œç­‰å¾…å¤šä¸ªäº‹ä»¶å®Œæˆï¼š

```java
// ç­‰å¾… 3 ä¸ªä»»åŠ¡å®Œæˆ
CountDownLatch latch = new CountDownLatch(3);

for (int i = 0; i < 3; i++) {
    executor.execute(() -> {
        try {
            doWork();
        } finally {
            latch.countDown();  // å®Œæˆä¸€ä¸ªä»»åŠ¡
        }
    });
}

latch.await();  // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
System.out.println("All tasks completed!");
```

### 6.2 CyclicBarrier

å¯é‡ç”¨çš„å±éšœï¼Œå¤šçº¿ç¨‹ç›¸äº’ç­‰å¾…ï¼š

```java
// 3 ä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    System.out.println("All threads reached barrier!");
});

for (int i = 0; i < 3; i++) {
    executor.execute(() -> {
        doPhase1();
        barrier.await();  // ç­‰å¾…å…¶ä»–çº¿ç¨‹
        
        doPhase2();
        barrier.await();  // å¯é‡å¤ä½¿ç”¨
    });
}
```

### 6.3 Semaphore

ä¿¡å·é‡ï¼Œæ§åˆ¶å¹¶å‘è®¿é—®æ•°é‡ï¼š

```java
// é™åˆ¶æœ€å¤š 10 ä¸ªå¹¶å‘
Semaphore semaphore = new Semaphore(10);

public void accessResource() {
    semaphore.acquire();  // è·å–è®¸å¯
    try {
        useResource();
    } finally {
        semaphore.release();  // é‡Šæ”¾è®¸å¯
    }
}
```

---

## 7. æŠ€æœ¯å…³è”åˆ†æ

### 7.1 JUC å¯¹æ¡†æ¶çš„å½±å“

```mermaid
graph TB
    subgraph JUC åŸºç¡€è®¾æ–½
        A[Executor] --> B[çº¿ç¨‹æ± ]
        C[Lock] --> D[é«˜çº§åŒæ­¥]
        E[Atomic] --> F[æ— é”ç¼–ç¨‹]
    end
    
    subgraph æ¡†æ¶åº”ç”¨
        B --> G[Tomcat çº¿ç¨‹æ± ]
        B --> H[Spring å¼‚æ­¥ä»»åŠ¡]
        D --> I[æ•°æ®åº“è¿æ¥æ± ]
        F --> J[é«˜æ€§èƒ½æ¡†æ¶]
    end
```

### 7.2 å¹¶å‘æ¨¡å‹æ¼”è¿›é¢„è§ˆ

```mermaid
timeline
    title Java å¹¶å‘æ¨¡å‹æ¼”è¿›
    section JDK 1.5
        åŸºç¡€è®¾æ–½ : Executor
                 : Lock
                 : ConcurrentMap
    section JDK 7
        åˆ†æ²»æ¨¡å‹ : Fork/Join
    section JDK 8
        å¼‚æ­¥ç¼–ç¨‹ : CompletableFuture
    section JDK 21
        è½»é‡çº¿ç¨‹ : Virtual Thread
```

---

## 8. æ¼”è¿›è§„å¾‹æ€»ç»“

### 8.1 ä»æ‰‹åŠ¨åˆ°æ¡†æ¶

```
æ‰‹åŠ¨åˆ›å»º Thread â†’ Executor æ¡†æ¶ç®¡ç†

å°†çº¿ç¨‹çš„åˆ›å»ºã€ç®¡ç†ã€é”€æ¯äº¤ç»™æ¡†æ¶ï¼Œ
å¼€å‘è€…åªå…³æ³¨ä»»åŠ¡æœ¬èº«ã€‚
```

### 8.2 ä»ç²—ç²’åº¦åˆ°ç»†ç²’åº¦

```
synchronizedï¼ˆå¯¹è±¡çº§ï¼‰â†’ Lockï¼ˆæ›´çµæ´»ï¼‰
Hashtableï¼ˆæ•´è¡¨é”ï¼‰â†’ ConcurrentHashMapï¼ˆåˆ†æ®µé”ï¼‰

é”çš„ç²’åº¦è¶Šç»†ï¼Œå¹¶å‘åº¦è¶Šé«˜ã€‚
```

### 8.3 ä»é˜»å¡åˆ°éé˜»å¡

```
synchronized ç­‰å¾… â†’ tryLock å°è¯•
é”ç«äº‰ â†’ CAS æ— é”

å‡å°‘çº¿ç¨‹é˜»å¡ï¼Œæé«˜ç³»ç»Ÿååé‡ã€‚
```

---

## 9. ç‰¹æ®Šå…ƒç´ 

### ğŸ‘¤ å…³é”®äººç‰©ï¼šDoug Lea

Doug Lea æ˜¯ Java å¹¶å‘ç¼–ç¨‹çš„å¥ åŸºäººï¼š

| è´¡çŒ® | å½±å“ |
|------|------|
| è®¾è®¡ JUC åŒ… | æˆä¸º Java å¹¶å‘ç¼–ç¨‹æ ‡å‡† |
| ç¼–å†™ ConcurrentHashMap | é«˜å¹¶å‘åœºæ™¯å¿…å¤‡ |
| Fork/Join æ¡†æ¶ | JDK 7 å¼•å…¥ |
| ã€ŠJavaå¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹å‚ä¸ | ç»å…¸å¹¶å‘ä¹¦ç± |

> ä»–æ˜¯çº½çº¦å·ç«‹å¤§å­¦å¥¥æ–¯å¨æˆˆåˆ†æ ¡çš„æ•™æˆï¼ŒJUC åŒ…å‡ ä¹å®Œå…¨ç”±ä»–ä¸€äººè®¾è®¡å’Œå®ç°ã€‚

### ğŸ’¼ é¢è¯•è€ƒç‚¹

**Q1: ConcurrentHashMap å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Ÿ**

ç­”ï¼šJDK 1.5-1.7 ä½¿ç”¨åˆ†æ®µé”ï¼ˆSegmentï¼‰ï¼Œæ¯ä¸ª Segment æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ HashTableï¼Œä¸åŒ Segment å¯ä»¥å¹¶å‘æ“ä½œã€‚JDK 1.8 æ”¹ä¸º CAS + synchronizedï¼Œé”ç²’åº¦æ›´ç»†ï¼ˆæ¡¶çº§åˆ«ï¼‰ã€‚

**Q2: çº¿ç¨‹æ± çš„æ ¸å¿ƒå‚æ•°æœ‰å“ªäº›ï¼Ÿ**

ç­”ï¼š
- corePoolSizeï¼šæ ¸å¿ƒçº¿ç¨‹æ•°
- maximumPoolSizeï¼šæœ€å¤§çº¿ç¨‹æ•°
- keepAliveTimeï¼šç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
- workQueueï¼šä»»åŠ¡é˜Ÿåˆ—
- threadFactoryï¼šçº¿ç¨‹å·¥å‚
- handlerï¼šæ‹’ç»ç­–ç•¥

**Q3: CountDownLatch å’Œ CyclicBarrier çš„åŒºåˆ«ï¼Ÿ**

ç­”ï¼š
- CountDownLatchï¼šä¸€æ¬¡æ€§çš„ï¼Œè®¡æ•°åˆ° 0 åä¸èƒ½é‡ç½®ï¼›ä¸€ä¸ªçº¿ç¨‹ç­‰å¾…å¤šä¸ªäº‹ä»¶
- CyclicBarrierï¼šå¯é‡ç”¨çš„ï¼›å¤šä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…ï¼Œåˆ°è¾¾å±éšœç‚¹åä¸€èµ·ç»§ç»­

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [JSR 166: Concurrency Utilities](https://jcp.org/en/jsr/detail?id=166)
- [Java Concurrency in Practice](https://jcip.net/)
- [Doug Lea's Home Page](http://gee.cs.oswego.edu/dl/)

---

<p align="center">
  â¬…ï¸ <a href="./01-æ³›å‹ä¸æ³¨è§£é©å‘½.md">ä¸Šä¸€ç¯‡ï¼šæ³›å‹ä¸æ³¨è§£é©å‘½</a> |
  ğŸ  <a href="../../">è¿”å›ç›®å½•</a> |
  <a href="./03-SSHæ¡†æ¶é»„é‡‘ç»„åˆ.md">ä¸‹ä¸€ç¯‡ï¼šSSHæ¡†æ¶é»„é‡‘ç»„åˆ</a> â¡ï¸
</p>

