---
layout: default
title: ç»“æœé›†æ˜ å°„è¯¦è§£
parent: ç»“æœé›†æ˜ å°„
grand_parent: MyBatis æºç æ•™ç¨‹
nav_order: 1
---

# ç»“æœé›†æ˜ å°„

> ğŸ“Š **éš¾åº¦**ï¼šğŸ”´ é«˜çº§ | â±ï¸ **é˜…è¯»æ—¶é—´**ï¼š35 åˆ†é’Ÿ
>
> ğŸ“ **æœ¬ç« æ‘˜è¦**ï¼šæ·±å…¥åˆ†æ MyBatis çš„ç»“æœé›†æ˜ å°„æœºåˆ¶ï¼Œäº†è§£å¦‚ä½•å°† JDBC ResultSet è½¬æ¢ä¸º Java å¯¹è±¡ï¼ŒæŒæ¡ TypeHandler å’Œè‡ªåŠ¨æ˜ å°„çš„å·¥ä½œåŸç†ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å­¦å®Œæœ¬ç« åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- ç†è§£ ResultSetHandler çš„æ ¸å¿ƒå¤„ç†é€»è¾‘
- æŒæ¡ TypeHandler çš„ç±»å‹è½¬æ¢æœºåˆ¶
- äº†è§£è‡ªåŠ¨æ˜ å°„ï¼ˆAutoMappingï¼‰çš„å®ç°åŸç†
- ç†è§£ ResultMap çš„åµŒå¥—æŸ¥è¯¢å’ŒåµŒå¥—ç»“æœæ˜ å°„

---

## ç¬¬ä¸€å±‚ï¼šå®è§‚æ¶æ„

### 1.1 ç»“æœæ˜ å°„å…¨æ™¯å›¾

```mermaid
flowchart TB
    PS[PreparedStatement.execute] --> RS[ResultSet<br/>JDBC ç»“æœé›†]
    RS --> RSH[ResultSetHandler<br/>handleResultSets]
    RSH --> RSW[ResultSetWrapper<br/>è·å–åˆ—åã€ç±»å‹ä¿¡æ¯]
    RSW --> RM[ResultMap<br/>æ˜ å°„é…ç½®]
    
    RM --> |éå†æ¯ä¸€è¡Œ| LOOP{å¾ªç¯å¤„ç†}
    LOOP --> CREATE[åˆ›å»ºç»“æœå¯¹è±¡<br/>ObjectFactory]
    CREATE --> MAP[å±æ€§æ˜ å°„<br/>è‡ªåŠ¨æ˜ å°„/æ˜¾å¼æ˜ å°„]
    MAP --> TH[TypeHandler<br/>getResult]
    TH --> OBJ[Java å¯¹è±¡]
    OBJ --> |ä¸‹ä¸€è¡Œ| LOOP
```

**å¤„ç†æµç¨‹è¯´æ˜ï¼š**

| æ­¥éª¤ | ç»„ä»¶ | æ“ä½œ |
|:----:|------|------|
| 1 | ResultSet | JDBC ç»“æœé›† |
| 2 | ResultSetHandler | å¤„ç†ç»“æœé›†å…¥å£ |
| 3 | ResultSetWrapper | è·å–åˆ—åã€ç±»å‹ä¿¡æ¯ |
| 4 | ResultMap | è¯»å–æ˜ å°„é…ç½® |
| 5 | ObjectFactory | åˆ›å»ºç»“æœå¯¹è±¡ |
| 6 | TypeHandler | ç±»å‹è½¬æ¢ |
| 7 | Java å¯¹è±¡ | æœ€ç»ˆç»“æœ |

### 1.2 æ ¸å¿ƒç»„ä»¶

```mermaid
flowchart TB
    RSH[ResultSetHandler<br/>ç»“æœé›†å¤„ç†å…¥å£] --> RSW[ResultSetWrapper<br/>åŒ…è£… ResultSet]
    RSH --> RM[ResultMap<br/>æ˜ å°„é…ç½®]
    RSW --> TH[TypeHandler<br/>ç±»å‹è½¬æ¢]
    RM --> OF[ObjectFactory<br/>å¯¹è±¡åˆ›å»º]
```

**ç»„ä»¶èŒè´£ï¼š**

| ç»„ä»¶ | èŒè´£ |
|------|------|
| **ResultSetHandler** | ç»“æœé›†å¤„ç†å…¥å£ |
| **ResultSetWrapper** | åŒ…è£… ResultSetï¼Œè·å–å…ƒæ•°æ® |
| **ResultMap** | å­˜å‚¨æ˜ å°„é…ç½® |
| **TypeHandler** | ç±»å‹è½¬æ¢ |
| **ObjectFactory** | åˆ›å»ºç»“æœå¯¹è±¡ |

---

## ç¬¬äºŒå±‚ï¼šæ¨¡å—èŒè´£

### 2.1 æ ¸å¿ƒç±»èŒè´£

| ç±»å | èŒè´£ | å…³é”®æ–¹æ³• |
|------|------|---------|
| `ResultSetHandler` | ç»“æœé›†å¤„ç†æ¥å£ | `handleResultSets()` |
| `DefaultResultSetHandler` | é»˜è®¤å®ç° | `handleRowValues()` |
| `ResultSetWrapper` | ResultSet åŒ…è£…å™¨ | `getColumnNames()`, `getJdbcType()` |
| `ResultMap` | æ˜ å°„é…ç½® | å­˜å‚¨åˆ—-å±æ€§æ˜ å°„å…³ç³» |
| `TypeHandler` | ç±»å‹è½¬æ¢ | `getResult()` |
| `ObjectFactory` | å¯¹è±¡å·¥å‚ | `create()` |

### 2.2 æ˜ å°„æ–¹å¼å¯¹æ¯”

| æ˜ å°„æ–¹å¼ | é…ç½® | ç‰¹ç‚¹ | æ€§èƒ½ |
|---------|------|------|------|
| **è‡ªåŠ¨æ˜ å°„** | æ— éœ€é…ç½® | åˆ—ååŒ¹é…å±æ€§å | è¾ƒå¥½ |
| **ResultMap** | XML é…ç½® | ç²¾ç¡®æ§åˆ¶æ˜ å°„ | æœ€å¥½ |
| **åµŒå¥—æŸ¥è¯¢** | association/collection | N+1 é—®é¢˜ | è¾ƒå·® |
| **åµŒå¥—ç»“æœ** | resultMap åµŒå¥— | ä¸€æ¬¡æŸ¥è¯¢ | å¥½ |

### 2.3 TypeHandler ä½“ç³»

```mermaid
classDiagram
    class TypeHandler~T~ {
        <<interface>>
        +setParameter()
        +getResult()
    }
    
    class BaseTypeHandler~T~ {
        <<abstract>>
        +setParameter()
        +getResult()
        #setNonNullParameter()*
        #getNullableResult()*
    }
    
    class StringTypeHandler
    class IntegerTypeHandler
    class DateTypeHandler
    class BooleanTypeHandler
    class LongTypeHandler
    class LocalDateTimeTypeHandler
    
    TypeHandler <|.. BaseTypeHandler
    BaseTypeHandler <|-- StringTypeHandler
    BaseTypeHandler <|-- IntegerTypeHandler
    BaseTypeHandler <|-- DateTypeHandler
    BaseTypeHandler <|-- BooleanTypeHandler
    BaseTypeHandler <|-- LongTypeHandler
    BaseTypeHandler <|-- LocalDateTimeTypeHandler
```

**å¸¸ç”¨ TypeHandlerï¼š**

| TypeHandler | Java ç±»å‹ | JDBC ç±»å‹ |
|-------------|----------|----------|
| StringTypeHandler | String | VARCHAR |
| IntegerTypeHandler | Integer | INTEGER |
| LongTypeHandler | Long | BIGINT |
| DateTypeHandler | Date | TIMESTAMP |
| LocalDateTimeTypeHandler | LocalDateTime | TIMESTAMP |

---

## ç¬¬ä¸‰å±‚ï¼šæºç æ·±å…¥

### 3.1 DefaultResultSetHandler.handleResultSets()

```java
public class DefaultResultSetHandler implements ResultSetHandler {

    @Override
    public List<Object> handleResultSets(Statement stmt) throws SQLException {
        
        final List<Object> multipleResults = new ArrayList<>();

        int resultSetCount = 0;
        
        // è·å–ç¬¬ä¸€ä¸ª ResultSet
        ResultSetWrapper rsw = getFirstResultSet(stmt);

        // è·å– ResultMap åˆ—è¡¨
        List<ResultMap> resultMaps = mappedStatement.getResultMaps();
        int resultMapCount = resultMaps.size();
        
        validateResultMapsCount(rsw, resultMapCount);
        
        // å¤„ç†æ¯ä¸ª ResultSet
        while (rsw != null && resultMapCount > resultSetCount) {
            ResultMap resultMap = resultMaps.get(resultSetCount);
            
            // å¤„ç† ResultSet
            handleResultSet(rsw, resultMap, multipleResults, null);
            
            // è·å–ä¸‹ä¸€ä¸ª ResultSet
            rsw = getNextResultSet(stmt);
            cleanUpAfterHandlingResultSet();
            resultSetCount++;
        }

        // å¤„ç†å¤šç»“æœé›†çš„æƒ…å†µ
        String[] resultSets = mappedStatement.getResultSets();
        if (resultSets != null) {
            while (rsw != null && resultSetCount < resultSets.length) {
                ResultMapping parentMapping = 
                    nextResultMaps.get(resultSets[resultSetCount]);
                if (parentMapping != null) {
                    String nestedResultMapId = parentMapping.getNestedResultMapId();
                    ResultMap resultMap = 
                        configuration.getResultMap(nestedResultMapId);
                    handleResultSet(rsw, resultMap, null, parentMapping);
                }
                rsw = getNextResultSet(stmt);
                cleanUpAfterHandlingResultSet();
                resultSetCount++;
            }
        }

        return collapseSingleResultList(multipleResults);
    }
}
```

### 3.2 handleRowValues() - æ ¸å¿ƒè¡Œå¤„ç†

```java
public void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap,
                           ResultHandler<?> resultHandler, 
                           RowBounds rowBounds,
                           ResultMapping parentMapping) throws SQLException {
    
    // æ˜¯å¦æœ‰åµŒå¥—ç»“æœæ˜ å°„
    if (resultMap.hasNestedResultMaps()) {
        ensureNoRowBounds();
        checkResultHandler();
        // å¤„ç†åµŒå¥—ç»“æœæ˜ å°„
        handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, 
                                         rowBounds, parentMapping);
    } else {
        // å¤„ç†ç®€å•ç»“æœæ˜ å°„
        handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, 
                                         rowBounds, parentMapping);
    }
}

// å¤„ç†ç®€å•ç»“æœæ˜ å°„
private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw,
                                               ResultMap resultMap,
                                               ResultHandler<?> resultHandler,
                                               RowBounds rowBounds,
                                               ResultMapping parentMapping) 
        throws SQLException {
    
    DefaultResultContext<Object> resultContext = new DefaultResultContext<>();
    ResultSet resultSet = rsw.getResultSet();
    
    // è·³è¿‡åˆ†é¡µåç§»é‡
    skipRows(resultSet, rowBounds);
    
    // éå†ç»“æœé›†
    while (shouldProcessMoreRows(resultContext, rowBounds) && 
           !resultSet.isClosed() && resultSet.next()) {
        
        // è§£æé‰´åˆ«å™¨
        ResultMap discriminatedResultMap = 
            resolveDiscriminatedResultMap(resultSet, resultMap, null);
        
        // è·å–ä¸€è¡Œæ•°æ®å¹¶æ˜ å°„ä¸ºå¯¹è±¡
        Object rowValue = getRowValue(rsw, discriminatedResultMap, null);
        
        // å­˜å‚¨ç»“æœ
        storeObject(resultHandler, resultContext, rowValue, 
                   parentMapping, resultSet);
    }
}
```

### 3.3 getRowValue() - å•è¡Œæ˜ å°„

```java
private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap,
                          String columnPrefix) throws SQLException {
    
    final ResultLoaderMap lazyLoader = new ResultLoaderMap();
    
    // 1. åˆ›å»ºç»“æœå¯¹è±¡
    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);
    
    if (rowValue != null && !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {
        
        // 2. åˆ›å»º MetaObject ç”¨äºè®¾ç½®å±æ€§
        final MetaObject metaObject = configuration.newMetaObject(rowValue);
        
        boolean foundValues = this.useConstructorMappings;
        
        // 3. è‡ªåŠ¨æ˜ å°„
        if (shouldApplyAutomaticMappings(resultMap, false)) {
            foundValues = applyAutomaticMappings(rsw, resultMap, 
                                                 metaObject, columnPrefix) 
                          || foundValues;
        }
        
        // 4. å±æ€§æ˜ å°„
        foundValues = applyPropertyMappings(rsw, resultMap, 
                                           metaObject, lazyLoader, columnPrefix)
                      || foundValues;
        
        foundValues = lazyLoader.size() > 0 || foundValues;
        
        rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() 
            ? rowValue 
            : null;
    }
    return rowValue;
}
```

### 3.4 createResultObject() - åˆ›å»ºç»“æœå¯¹è±¡

```java
private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap,
                                  ResultLoaderMap lazyLoader, 
                                  String columnPrefix) throws SQLException {
    
    this.useConstructorMappings = false;
    final List<Class<?>> constructorArgTypes = new ArrayList<>();
    final List<Object> constructorArgs = new ArrayList<>();
    
    // 1. åˆ›å»ºç»“æœå¯¹è±¡
    Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes,
                                            constructorArgs, columnPrefix);
    
    if (resultObject != null && !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {
        
        // 2. è·å–å±æ€§æ˜ å°„
        final List<ResultMapping> propertyMappings = resultMap.getPropertyResultMappings();
        
        for (ResultMapping propertyMapping : propertyMappings) {
            // 3. æ£€æŸ¥æ˜¯å¦éœ€è¦å»¶è¿ŸåŠ è½½
            if (propertyMapping.getNestedQueryId() != null && 
                propertyMapping.isLazy()) {
                
                // åˆ›å»ºä»£ç†å¯¹è±¡æ”¯æŒå»¶è¿ŸåŠ è½½
                resultObject = configuration.getProxyFactory()
                    .createProxy(resultObject, lazyLoader, configuration,
                                objectFactory, constructorArgTypes, constructorArgs);
                break;
            }
        }
    }
    
    this.useConstructorMappings = resultObject != null && 
                                   !constructorArgTypes.isEmpty();
    return resultObject;
}

// ä½¿ç”¨æ„é€ å™¨æˆ–å¯¹è±¡å·¥å‚åˆ›å»ºå¯¹è±¡
private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap,
                                  List<Class<?>> constructorArgTypes,
                                  List<Object> constructorArgs,
                                  String columnPrefix) throws SQLException {
    
    final Class<?> resultType = resultMap.getType();
    final MetaClass metaType = MetaClass.forClass(resultType, reflectorFactory);
    final List<ResultMapping> constructorMappings = 
        resultMap.getConstructorResultMappings();

    // æƒ…å†µ1ï¼šæœ‰ TypeHandlerï¼Œç›´æ¥è½¬æ¢
    if (hasTypeHandlerForResultObject(rsw, resultType)) {
        return createPrimitiveResultObject(rsw, resultMap, columnPrefix);
    }
    
    // æƒ…å†µ2ï¼šæœ‰æ„é€ å™¨æ˜ å°„
    if (!constructorMappings.isEmpty()) {
        return createParameterizedResultObject(rsw, resultType, constructorMappings,
                                              constructorArgTypes, constructorArgs, 
                                              columnPrefix);
    }
    
    // æƒ…å†µ3ï¼šæœ‰é»˜è®¤æ„é€ å™¨æˆ–è‡ªåŠ¨æ˜ å°„æ„é€ å™¨
    if (resultType.isInterface() || metaType.hasDefaultConstructor()) {
        return objectFactory.create(resultType);
    }
    
    // æƒ…å†µ4ï¼šå°è¯•è‡ªåŠ¨æ˜ å°„æ„é€ å™¨
    if (shouldApplyAutomaticMappings(resultMap, false)) {
        return createByConstructorSignature(rsw, resultMap, columnPrefix, resultType,
                                           constructorArgTypes, constructorArgs);
    }
    
    throw new ExecutorException("Do not know how to create an instance of " + resultType);
}
```

### 3.5 applyAutomaticMappings() - è‡ªåŠ¨æ˜ å°„

```java
private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap,
                                       MetaObject metaObject, 
                                       String columnPrefix) throws SQLException {
    
    // è·å–æœªæ˜ å°„çš„åˆ—å
    List<UnMappedColumnAutoMapping> autoMapping = 
        createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);
    
    boolean foundValues = false;
    
    if (!autoMapping.isEmpty()) {
        for (UnMappedColumnAutoMapping mapping : autoMapping) {
            // ä½¿ç”¨ TypeHandler è·å–å€¼
            final Object value = mapping.typeHandler.getResult(
                rsw.getResultSet(), mapping.column);
            
            if (value != null) {
                foundValues = true;
            }
            
            if (value != null || (configuration.isCallSettersOnNulls() && 
                                  !mapping.primitive)) {
                // è®¾ç½®å±æ€§å€¼
                metaObject.setValue(mapping.property, value);
            }
        }
    }
    return foundValues;
}

// åˆ›å»ºè‡ªåŠ¨æ˜ å°„
private List<UnMappedColumnAutoMapping> createAutomaticMappings(
        ResultSetWrapper rsw, ResultMap resultMap,
        MetaObject metaObject, String columnPrefix) throws SQLException {
    
    final String mapKey = resultMap.getId() + ":" + columnPrefix;
    List<UnMappedColumnAutoMapping> autoMapping = autoMappingsCache.get(mapKey);
    
    if (autoMapping == null) {
        autoMapping = new ArrayList<>();
        
        // è·å–æ‰€æœ‰æœªæ˜ å°„çš„åˆ—å
        final List<String> unmappedColumnNames = 
            rsw.getUnmappedColumnNames(resultMap, columnPrefix);
        
        for (String columnName : unmappedColumnNames) {
            // åˆ—åè½¬å±æ€§å
            String propertyName = columnName;
            if (columnPrefix != null && !columnPrefix.isEmpty()) {
                if (columnName.toUpperCase(Locale.ENGLISH)
                              .startsWith(columnPrefix)) {
                    propertyName = columnName.substring(columnPrefix.length());
                } else {
                    continue;
                }
            }
            
            // é©¼å³°è½¬æ¢
            final String property = metaObject.findProperty(propertyName,
                configuration.isMapUnderscoreToCamelCase());
            
            if (property != null && metaObject.hasSetter(property)) {
                if (resultMap.getMappedProperties().contains(property)) {
                    continue; // å·²æ˜¾å¼æ˜ å°„ï¼Œè·³è¿‡
                }
                
                // è·å–å±æ€§ç±»å‹
                final Class<?> propertyType = metaObject.getSetterType(property);
                
                if (typeHandlerRegistry.hasTypeHandler(propertyType, 
                                                       rsw.getJdbcType(columnName))) {
                    // è·å– TypeHandler
                    final TypeHandler<?> typeHandler = 
                        rsw.getTypeHandler(propertyType, columnName);
                    
                    autoMapping.add(new UnMappedColumnAutoMapping(
                        columnName, property, typeHandler, 
                        propertyType.isPrimitive()));
                }
            }
        }
        autoMappingsCache.put(mapKey, autoMapping);
    }
    return autoMapping;
}
```

### 3.6 TypeHandler.getResult() - ç±»å‹è½¬æ¢

```java
public abstract class BaseTypeHandler<T> extends TypeReference<T> 
        implements TypeHandler<T> {

    @Override
    public T getResult(ResultSet rs, String columnName) throws SQLException {
        try {
            return getNullableResult(rs, columnName);
        } catch (Exception e) {
            throw new ResultMapException(
                "Error attempting to get column '" + columnName + 
                "' from result set. Cause: " + e, e);
        }
    }

    @Override
    public T getResult(ResultSet rs, int columnIndex) throws SQLException {
        try {
            return getNullableResult(rs, columnIndex);
        } catch (Exception e) {
            throw new ResultMapException(
                "Error attempting to get column #" + columnIndex + 
                " from result set. Cause: " + e, e);
        }
    }

    // å­ç±»å®ç°å…·ä½“çš„ç±»å‹è½¬æ¢
    public abstract T getNullableResult(ResultSet rs, String columnName) 
            throws SQLException;
    public abstract T getNullableResult(ResultSet rs, int columnIndex) 
            throws SQLException;
}

// ç¤ºä¾‹ï¼šStringTypeHandler
public class StringTypeHandler extends BaseTypeHandler<String> {

    @Override
    public String getNullableResult(ResultSet rs, String columnName) 
            throws SQLException {
        return rs.getString(columnName);
    }

    @Override
    public String getNullableResult(ResultSet rs, int columnIndex) 
            throws SQLException {
        return rs.getString(columnIndex);
    }
}

// ç¤ºä¾‹ï¼šLocalDateTimeTypeHandler
public class LocalDateTimeTypeHandler extends BaseTypeHandler<LocalDateTime> {

    @Override
    public LocalDateTime getNullableResult(ResultSet rs, String columnName) 
            throws SQLException {
        Timestamp timestamp = rs.getTimestamp(columnName);
        return getLocalDateTime(timestamp);
    }

    private static LocalDateTime getLocalDateTime(Timestamp timestamp) {
        if (timestamp != null) {
            return timestamp.toLocalDateTime();
        }
        return null;
    }
}
```

### 3.7 ResultMap ç»“æ„

```java
public class ResultMap {
    
    private Configuration configuration;
    private String id;                           // ResultMap ID
    private Class<?> type;                       // ç»“æœç±»å‹
    private List<ResultMapping> resultMappings;  // æ‰€æœ‰æ˜ å°„
    private List<ResultMapping> idResultMappings;     // ID æ˜ å°„
    private List<ResultMapping> constructorResultMappings; // æ„é€ å™¨æ˜ å°„
    private List<ResultMapping> propertyResultMappings;    // å±æ€§æ˜ å°„
    private Set<String> mappedColumns;           // å·²æ˜ å°„çš„åˆ—
    private Set<String> mappedProperties;        // å·²æ˜ å°„çš„å±æ€§
    private Discriminator discriminator;         // é‰´åˆ«å™¨
    private boolean hasNestedResultMaps;         // æ˜¯å¦æœ‰åµŒå¥— ResultMap
    private boolean hasNestedQueries;            // æ˜¯å¦æœ‰åµŒå¥—æŸ¥è¯¢
    private Boolean autoMapping;                 // æ˜¯å¦è‡ªåŠ¨æ˜ å°„
}

public class ResultMapping {
    
    private Configuration configuration;
    private String property;         // Java å±æ€§å
    private String column;           // æ•°æ®åº“åˆ—å
    private Class<?> javaType;       // Java ç±»å‹
    private JdbcType jdbcType;       // JDBC ç±»å‹
    private TypeHandler<?> typeHandler;  // ç±»å‹å¤„ç†å™¨
    private String nestedResultMapId;    // åµŒå¥— ResultMap ID
    private String nestedQueryId;        // åµŒå¥—æŸ¥è¯¢ ID
    private Set<String> notNullColumns;
    private String columnPrefix;
    private List<ResultFlag> flags;      // æ ‡å¿—ï¼ˆIDã€CONSTRUCTORï¼‰
    private boolean lazy;                // æ˜¯å¦å»¶è¿ŸåŠ è½½
}
```

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ResultSetHandler**ï¼šè´Ÿè´£å°† ResultSet è½¬æ¢ä¸º Java å¯¹è±¡åˆ—è¡¨
2. **TypeHandler**ï¼šè´Ÿè´£ JDBC ç±»å‹ä¸ Java ç±»å‹ä¹‹é—´çš„è½¬æ¢
3. **è‡ªåŠ¨æ˜ å°„**ï¼šæ ¹æ®åˆ—åè‡ªåŠ¨åŒ¹é…å±æ€§åï¼ˆæ”¯æŒé©¼å³°è½¬æ¢ï¼‰
4. **ResultMap**ï¼šæ˜¾å¼é…ç½®åˆ—ä¸å±æ€§çš„æ˜ å°„å…³ç³»

### ç»“æœæ˜ å°„æµç¨‹ç²¾ç®€ç‰ˆ

```
ResultSetHandler.handleResultSets()
    â””â”€â”€ handleRowValuesForSimpleResultMap()
            â””â”€â”€ while (resultSet.next()) {
                    getRowValue()
                        â”œâ”€â”€ createResultObject()  â†’ åˆ›å»ºå¯¹è±¡
                        â”œâ”€â”€ applyAutomaticMappings() â†’ è‡ªåŠ¨æ˜ å°„
                        â””â”€â”€ applyPropertyMappings()  â†’ å±æ€§æ˜ å°„
                            â””â”€â”€ TypeHandler.getResult() â†’ ç±»å‹è½¬æ¢
                }
```

### æ€§èƒ½å»ºè®®

1. **ä¼˜å…ˆä½¿ç”¨ ResultMap**ï¼šæ˜¾å¼æ˜ å°„æ¯”è‡ªåŠ¨æ˜ å°„æ›´é«˜æ•ˆ
2. **é¿å…åµŒå¥—æŸ¥è¯¢**ï¼šN+1 æŸ¥è¯¢é—®é¢˜ï¼Œä½¿ç”¨åµŒå¥—ç»“æœæ˜ å°„ä»£æ›¿
3. **åˆç†ä½¿ç”¨å»¶è¿ŸåŠ è½½**ï¼šæŒ‰éœ€åŠ è½½å…³è”å¯¹è±¡
4. **æ³¨å†Œè‡ªå®šä¹‰ TypeHandler**ï¼šç‰¹æ®Šç±»å‹éœ€è¦è‡ªå®šä¹‰å¤„ç†å™¨

---

## ç³»åˆ—å®Œç»“ ğŸ‰

æ­å–œä½ å®Œæˆäº† MyBatis æºç æ·±åº¦è§£æç³»åˆ—çš„å­¦ä¹ ï¼

é€šè¿‡è¿™ 5 ç¯‡æ–‡ç« ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†ï¼š

- âœ… MyBatis æ•´ä½“æ¶æ„å’Œæ ¸å¿ƒç»„ä»¶
- âœ… é…ç½®æ–‡ä»¶è§£æå’Œ Configuration æ„å»º
- âœ… Mapper æ¥å£çš„åŠ¨æ€ä»£ç†å®ç°
- âœ… SQL æ‰§è¡Œçš„å®Œæ•´æµç¨‹
- âœ… ç»“æœé›†åˆ° Java å¯¹è±¡çš„æ˜ å°„æœºåˆ¶

ç»§ç»­æ·±å…¥æ¢ç´¢ MyBatis çš„æ›´å¤šç‰¹æ€§å§ï¼

---

| â¬…ï¸ ä¸Šä¸€ç«  | ğŸ  ç›®å½• | ä¸‹ä¸€ç«  â¡ï¸ |
|:----------|:------:|----------:|
| [SQL æ‰§è¡Œæµç¨‹](../04-SQLæ‰§è¡Œæµç¨‹/01-SQLæ‰§è¡Œæµç¨‹.md) | [è¿”å›ç›®å½•](../../) | ğŸ‰ ç³»åˆ—å®Œç»“ |

